import os,time,zipfile,re,json
from datetime import datetime
from LANG import zh_func_lse_text,zdy_gui_lse_text,zdyconfig

class Method:
    def __init__(self, name, code):
        self.name = name
        self.code = code
class Field:
    def __init__(self, name):
        self.name = name
class Code:
    def __init__(self, instructions):
        self.instructions = instructions

def lse(FileGUI,icon_var,cGuilang_entry):
    global CONST_SOURCE,CONST_JAR,filePath,fileName
    CONST_SOURCE = icon_var
    fileName = os.path.basename(os.path.splitext(icon_var)[0])
    CONST_JAR = FileGUI+"/extracted"
    filePath = FileGUI+"/output.json"
    def runtcGui():
        global zdy,a0,lse1,lse2,lse3,lse4,lse5,lse6,lse7,lse8,lse9,lse10,lse11,lse12,lse13,lse14,lse15,lse16,lse17,lse18
        zdy,a0 = zdyconfig()
        if cGuilang_entry == "中文简体":
            lse1,lse2,lse3,lse4,lse5,lse6,lse7,lse8,lse9,lse10,lse11,lse12,lse13,lse14,lse15,lse16,lse17,lse18 = zh_func_lse_text()
        if cGuilang_entry == f"{zdy}":
            lse1,lse2,lse3,lse4,lse5,lse6,lse7,lse8,lse9,lse10,lse11,lse12,lse13,lse14,lse15,lse16,lse17,lse18 = zdy_gui_lse_text()
    runtcGui()
    aaeeoo()

logt = ''
def logs(s):
    global logt
    now = datetime.now()
    logt = ''.join([logt, f'[{now.hour:02d}:{now.minute:02d}:{now.second:02d}] {s}\n'])
    print(f'[{now.hour:02d}:{now.minute:02d}:{now.second:02d}] {s}')
def parse_string(s):
    lines = s.split('\n')[1:]
    g = re.search(r'class (.*) {', lines[0])
    if g is None:
        return [None, None, None]
    class_name = g.group(1)
    methods = []
    fields = []
    for i in range(1, len(lines)):
        line = lines[i].strip().replace('static {};', 'public staticMethod();')
        k = None
        if line.startswith('public'):
            k = 'public'
        elif line.startswith('private'):
            k = 'private'
        elif line.startswith('protected'):
            k = 'protected'
        if k is not None:
            if '(' in line:
                method_name = re.search(k + r' (.*)\(', line).group(1)
                code_lines = []
                i += 1
                while not lines[i] == '':
                    code_lines.append(lines[i])
                    i += 1
                code_str = '\n'.join(code_lines)
                instructions = re.findall(r'\d+: (.*)', code_str)
                code = Code(instructions)
                method = Method(method_name, code)
                methods.append(method)
            elif 'Code:' not in line:
                field_name = re.search(k + r' (.*) (.*);', line).group(2)
                field = Field(field_name)
                fields.append(field)
            else:
                method_name = re.search(r'(.*);', line).group(1)
                code_lines = []
                i += 1
                while not lines[i].startswith('}'):
                    code_lines.append(lines[i])
                    i += 1
                code_str = '\n'.join(code_lines)
                instructions = re.findall(r'\d+: (.*)', code_str)
                code = Code(instructions)
                method = Method(method_name, code)
                methods.append(method)
    return [class_name, methods, fields]
def main():
    logs(f'{lse1}')
    time.sleep(2)
    if not os.path.exists("extracted"):
        logs(f'{lse2}')
        zf = zipfile.ZipFile(CONST_SOURCE)
        zf.extractall(path=CONST_JAR)
        logs(f'{lse3}')
    time.sleep(1)
    ar = [{
        "authors": "FengMing",
        "name": "ldcStringExtractor-output",
        "desc": "Automatically generated by ldcStringExtractor.\nThe output is only for one class",
        "mods": f"{fileName}"
    }]
    logs(f'{lse4}')
    for root, dirs, files in os.walk(CONST_JAR):
        for f in files:
            if os.path.splitext(f)[1] == ".class":
                logs("Decompile... {}".format(os.path.join(root, f)))
                try:
                    resultC = os.popen('javap -c "' + os.path.join(root, f) + '"')
                except:
                    logs(f'{lse5}')
                    input(f'{lse6}')
                cms = []
                if resultC is not None:
                    name, methods, fields = parse_string(resultC.read())
                    if name is None or methods is None or fields is None:
                        resultC.close()
                        continue
                    for m in methods:
                        if ' ' in m.name:
                            m.name = m.name.split(' ')[-1]
                        if '.' in m.name:
                            m.name = '<init>'
                        if m.name == 'staticMethod':
                            m.name = '<clinit>'
                        # logs(m.name + '-----------')
                        for c in m.code.instructions:
                            if c.startswith("ldc") or c.startswith("ldc_w"):
                                pos = c.rfind('// String ')
                                if pos < 0:
                                    continue
                                cms.append([name, m.name, c[pos + 10:]])
                                # logs(c)
                    resultC.close()
                else:
                    logs(f"{lse7}")
                    return
                if not cms:
                    logs(f"{lse8}")
                    continue
                for i in range(0, len(cms)):
                    ar.append({
                        'key': cms[i][2],
                        'value': "vaultpatcher.modify.ldc" + str(i),
                        'target_class': {
                            'name': cms[i][0],
                            'method': cms[i][1]
                        }
                    })
    logs(f'{lse9}')
    with open(filePath, "w") as jf:
        logs(f'{lse10}{filePath}')
        json.dump(ar, jf)
    # logs(ar)
def inita():
    logs('--------ldcStringExtractor--------')
    logs('By FengMing V1.0')
    logs(f'{lse11}' % (fileName))
    logs(f'{lse12}' % (filePath))
    logs(f'{lse13}')
    logs(f'{lse14}')
    logs(f'{lse15}')
    javah = os.environ.get('JAVA_HOME')
    if javah:
        logs(f'JAVA_HOME: {javah}')
    else:
        logs(f'{lse16}')
    logs('--------ldcStringExtractor--------')
    input(f'{lse17}')
def aaeeoo():
    inita()
    main()
    logs(f'{lse18}')
    with open(CONST_JAR+"/logs.txt", "w") as lf:
        lf.write(logt)
    input(f'{lse6}')